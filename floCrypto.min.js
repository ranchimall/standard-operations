!function(EXPORTS){"use strict";const floCrypto="object"===typeof module?module.exports:window.floCrypto={},p=BigInteger("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F",16),ecparams=EllipticCurve.getSECCurveByName("secp256k1"),ascii_alternatives="‘ '\n’ '\n“ \"\n” \"\n– --\n— ---\n≥ >=\n≤ <=\n≠ !=\n× *\n÷ /\n← <-\n→ ->\n↔ <->\n⇒ =>\n⇐ <=\n⇔ <=>",exponent1=()=>p.add(BigInteger.ONE).divide(BigInteger("4"));function getUncompressedPublicKey(compressedPublicKey){let pubKeyBytes=Crypto.util.hexToBytes(compressedPublicKey);let prefix_modulus=pubKeyBytes.shift()%2;pubKeyBytes.unshift(0);let x=new BigInteger(pubKeyBytes),xDecimalValue=x.toString(),y=function(x){let exp=exponent1();return x.modPow(BigInteger("3"),p).add(BigInteger("7")).mod(p).modPow(exp,p)}(x),yDecimalValue=y.toString();return prefix_modulus!==y.mod(BigInteger("2")).toString()%2&&(yDecimalValue=y.negate().mod(p).toString()),{x:xDecimalValue,y:yDecimalValue}}coinjs.compressed=!0,floCrypto.randInt=function(min,max){return min=Math.ceil(min),max=Math.floor(max),Math.floor(securedMathRandom()*(max-min+1))+min},floCrypto.randString=function(length,alphaNumeric=!0){for(var result="",characters=alphaNumeric?"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789":"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_+-./*?@#&$<>=[]{}():",i=0;i<length;i++)result+=characters.charAt(Math.floor(securedMathRandom()*characters.length));return result},floCrypto.encryptData=function(data,receiverPublicKeyHex){var senderECKeyData=function(){let privateKey=ellipticCurveEncryption.senderRandom();return{privateKey:privateKey,senderPublicKeyString:ellipticCurveEncryption.senderPublicString(privateKey)}}(),senderDerivedKey=function(receiverPublicKeyHex,senderPrivateKey){let receiverPublicKeyString=getUncompressedPublicKey(receiverPublicKeyHex);return ellipticCurveEncryption.senderSharedKeyDerivation(receiverPublicKeyString.x,receiverPublicKeyString.y,senderPrivateKey)}(receiverPublicKeyHex,senderECKeyData.privateKey);let senderKey=senderDerivedKey.XValue+senderDerivedKey.YValue;return{secret:Crypto.AES.encrypt(data,senderKey),senderPublicKeyString:senderECKeyData.senderPublicKeyString}},floCrypto.decryptData=function(data,privateKeyHex){var receiverECKeyData={};if("string"!=typeof privateKeyHex)throw new Error("No private key found.");let privateKey=function(pk_wif,isPubKeyCompressed=!1){let pk=Bitcoin.Base58.decode(pk_wif);return pk.shift(),pk.splice(-4,4),1==isPubKeyCompressed&&pk.pop(),pk.unshift(0),{privateKeyDecimal:BigInteger(pk).toString(),privateKeyHex:Crypto.util.bytesToHex(pk)}}(privateKeyHex,!0);if("string"!=typeof privateKey.privateKeyDecimal)throw new Error("Failed to detremine your private key.");receiverECKeyData.privateKey=privateKey.privateKeyDecimal;var senderPublicKeyString,receiverPrivateKey,receiverDerivedKey=(senderPublicKeyString=data.senderPublicKeyString,receiverPrivateKey=receiverECKeyData.privateKey,ellipticCurveEncryption.receiverSharedKeyDerivation(senderPublicKeyString.XValuePublicString,senderPublicKeyString.YValuePublicString,receiverPrivateKey));let receiverKey=receiverDerivedKey.XValue+receiverDerivedKey.YValue;return Crypto.AES.decrypt(data.secret,receiverKey)},floCrypto.signData=function(data,privateKeyHex){var key=new Bitcoin.ECKey(privateKeyHex),messageHash=Crypto.SHA256(data),messageSign=Bitcoin.ECDSA.sign(messageHash,key.priv);return Crypto.util.bytesToHex(messageSign)},floCrypto.verifySign=function(data,signatureHex,publicKeyHex){var msgHash=Crypto.SHA256(data),sigBytes=Crypto.util.hexToBytes(signatureHex),publicKeyPoint=ecparams.getCurve().decodePointHex(publicKeyHex);return Bitcoin.ECDSA.verify(msgHash,sigBytes,publicKeyPoint)};const generateNewID=floCrypto.generateNewID=function(){var key=new Bitcoin.ECKey(!1);return key.setCompressed(!0),{floID:key.getBitcoinAddress(),pubKey:key.getPubKeyHex(),privKey:key.getBitcoinWalletImportFormat()}};Object.defineProperties(floCrypto,{newID:{get:()=>generateNewID()},hashID:{value:str=>{let bytes=ripemd160(Crypto.SHA256(str,{asBytes:!0}),{asBytes:!0});bytes.unshift(bitjs.pub);var checksum=Crypto.SHA256(Crypto.SHA256(bytes,{asBytes:!0}),{asBytes:!0}).slice(0,4);return bitjs.Base58.encode(bytes.concat(checksum))}},tmpID:{get:()=>{let bytes=Crypto.util.randomBytes(20);bytes.unshift(bitjs.pub);var checksum=Crypto.SHA256(Crypto.SHA256(bytes,{asBytes:!0}),{asBytes:!0}).slice(0,4);return bitjs.Base58.encode(bytes.concat(checksum))}}}),floCrypto.getPubKeyHex=function(privateKeyHex){if(!privateKeyHex)return null;var key=new Bitcoin.ECKey(privateKeyHex);return null==key.priv?null:(key.setCompressed(!0),key.getPubKeyHex())},floCrypto.getFloID=function(keyHex){if(!keyHex)return null;try{var key=new Bitcoin.ECKey(keyHex);return null==key.priv&&key.setPub(keyHex),key.getBitcoinAddress()}catch{return null}},floCrypto.getAddress=function(privateKeyHex,strict=!1){if(!privateKeyHex)return;var key=new Bitcoin.ECKey(privateKeyHex);if(null==key.priv)return null;key.setCompressed(!0);let pubKey=key.getPubKeyHex();switch(bitjs.Base58.decode(privateKeyHex)[0]){case coinjs.priv:return coinjs.bech32Address(pubKey).address;case bitjs.priv:return bitjs.pubkey2address(pubKey);default:return!strict&&bitjs.pubkey2address(pubKey)}},floCrypto.verifyPrivKey=function(privateKeyHex,pubKey_floID,isfloID=!0){if(!privateKeyHex||!pubKey_floID)return!1;try{var key=new Bitcoin.ECKey(privateKeyHex);return null!=key.priv&&(key.setCompressed(!0),!(!isfloID||pubKey_floID!=key.getBitcoinAddress())||!isfloID&&pubKey_floID.toUpperCase()==key.getPubKeyHex().toUpperCase())}catch{return null}},floCrypto.getMultisigAddress=function(publicKeyList,requiredSignatures){if(!Array.isArray(publicKeyList)||!publicKeyList.length)return null;if(!Number.isInteger(requiredSignatures)||requiredSignatures<1||requiredSignatures>publicKeyList.length)return null;try{return bitjs.pubkeys2multisig(publicKeyList,requiredSignatures)}catch{return null}},floCrypto.decodeRedeemScript=function(redeemScript){try{return bitjs.transaction().decodeRedeemScript(redeemScript)}catch{return null}},floCrypto.validateFloID=function(floID,regularOnly=!1){if(!floID)return!1;try{let addr=new Bitcoin.Address(floID);return!regularOnly||addr.version==Bitcoin.Address.standardVersion}catch{return!1}},floCrypto.validateAddr=function(address,std=!0,bech=!0){let raw=decodeAddress(address);return!!raw&&(void 0!==raw.version?0!=std&&!!(!0===std||!Array.isArray(std)&&std===raw.version||Array.isArray(std)&&std.includes(raw.version)):void 0!==raw.bech_version&&(!1!==bech&&!!(!0===bech||!Array.isArray(bech)&&bech===raw.bech_version||Array.isArray(bech)&&bech.includes(raw.bech_version))))},floCrypto.verifyPubKey=function(pubKeyHex,address){let raw=decodeAddress(address);if(!raw)return;let pub_hash=Crypto.util.bytesToHex(ripemd160(Crypto.SHA256(Crypto.util.hexToBytes(pubKeyHex),{asBytes:!0})));return void 0!==raw.bech_version&&32==raw.bytes.length&&(raw.hex=Crypto.util.bytesToHex(ripemd160(raw.bytes,{asBytes:!0}))),pub_hash===raw.hex},floCrypto.toFloID=function(address,options=null){if(!address)return;let raw=decodeAddress(address);if(!raw)return;if(options){if(!(void 0===raw.version||options.std&&options.std.includes(raw.version)))return;if(!(void 0===raw.bech_version||options.bech&&options.bech.includes(raw.bech_version)))return}raw.bytes.unshift(bitjs.pub);let hash=Crypto.SHA256(Crypto.SHA256(raw.bytes,{asBytes:!0}),{asBytes:!0});return bitjs.Base58.encode(raw.bytes.concat(hash.slice(0,4)))},floCrypto.rawToFloID=function(raw_bytes){if("string"==typeof raw_bytes&&(raw_bytes=Crypto.util.hexToBytes(raw_bytes)),20!=raw_bytes.length)return null;raw_bytes.unshift(bitjs.pub);let hash=Crypto.SHA256(Crypto.SHA256(raw_bytes,{asBytes:!0}),{asBytes:!0});return bitjs.Base58.encode(raw_bytes.concat(hash.slice(0,4)))},floCrypto.toMultisigFloID=function(address,options=null){if(!address)return;let raw=decodeAddress(address);if(!raw)return;if(options){if(!(void 0===raw.version||options.std&&options.std.includes(raw.version)))return;if(!(void 0===raw.bech_version||options.bech&&options.bech.includes(raw.bech_version)))return}if(void 0!==raw.bech_version){if(32!=raw.bytes.length)return;raw.bytes=ripemd160(raw.bytes,{asBytes:!0})}raw.bytes.unshift(bitjs.multisig);let hash=Crypto.SHA256(Crypto.SHA256(raw.bytes,{asBytes:!0}),{asBytes:!0});return bitjs.Base58.encode(raw.bytes.concat(hash.slice(0,4)))},floCrypto.isSameAddr=function(addr1,addr2){if(!addr1||!addr2)return;let raw1=decodeAddress(addr1),raw2=decodeAddress(addr2);return!(!raw1||!raw2)&&(void 0!==raw1.bech_version&&32==raw1.bytes.length&&(raw1.hex=Crypto.util.bytesToHex(ripemd160(raw1.bytes,{asBytes:!0}))),void 0!==raw2.bech_version&&32==raw2.bytes.length&&(raw2.hex=Crypto.util.bytesToHex(ripemd160(raw2.bytes,{asBytes:!0}))),raw1.hex===raw2.hex)};const decodeAddress=floCrypto.decodeAddr=function(address){if(address){if(33==address.length||34==address.length){let decode=bitjs.Base58.decode(address),bytes=decode.slice(0,decode.length-4),checksum=decode.slice(decode.length-4),hash=Crypto.SHA256(Crypto.SHA256(bytes,{asBytes:!0}),{asBytes:!0});return hash[0]!=checksum[0]||hash[1]!=checksum[1]||hash[2]!=checksum[2]||hash[3]!=checksum[3]?null:{version:bytes.shift(),hex:Crypto.util.bytesToHex(bytes),bytes:bytes}}if(42==address.length||62==address.length){let decode=coinjs.bech32_decode(address);if(decode){let bytes=decode.data,bech_version=bytes.shift();return bytes=coinjs.bech32_convert(bytes,5,8,!1),{bech_version:bech_version,hrp:decode.hrp,hex:Crypto.util.bytesToHex(bytes),bytes:bytes}}return null}}};floCrypto.createShamirsSecretShares=function(str,total_shares,threshold_limit){try{if(str.length>0){var strHex=shamirSecretShare.str2hex(str);return shamirSecretShare.share(strHex,total_shares,threshold_limit)}return!1}catch{return!1}};const retrieveShamirSecret=floCrypto.retrieveShamirSecret=function(sharesArray){try{if(sharesArray.length>0){var comb=shamirSecretShare.combine(sharesArray.slice(0,sharesArray.length));return comb=shamirSecretShare.hex2str(comb)}return!1}catch{return!1}};floCrypto.verifyShamirsSecret=function(sharesArray,str){return str?retrieveShamirSecret(sharesArray)===str:null};const validateASCII=floCrypto.validateASCII=function(string,bool=!0){if("string"!=typeof string)return null;if(bool){let x;for(let i=0;i<string.length;i++)if(x=string.charCodeAt(i),x<32||x>127)return!1;return!0}{let x,invalids={};for(let i=0;i<string.length;i++)x=string.charCodeAt(i),(x<32||x>127)&&(x in invalids?invalids[string[i]].push(i):invalids[string[i]]=[i]);return!Object.keys(invalids).length||invalids}};floCrypto.convertToASCII=function(string,mode="soft-remove"){let chars=validateASCII(string,!1);if(!0===chars)return string;if(null===chars)return null;let convertor,result=string,refAlt={};if(ascii_alternatives.split("\n").forEach((a=>refAlt[a[0]]=a.slice(2))),"hard-unicode"===(mode=mode.toLowerCase()))convertor=c=>`\\u${("000"+c.charCodeAt().toString(16)).slice(-4)}`;else if("soft-unicode"===mode)convertor=c=>refAlt[c]||`\\u${("000"+c.charCodeAt().toString(16)).slice(-4)}`;else if("hard-remove"===mode)convertor=c=>"";else{if("soft-remove"!==mode)return null;convertor=c=>refAlt[c]||""}for(let c in chars)result=result.replaceAll(c,convertor(c));return result},floCrypto.revertUnicode=function(string){return string.replace(/\\u[\dA-F]{4}/gi,(m=>String.fromCharCode(parseInt(m.replace(/\\u/g,""),16))))}}();